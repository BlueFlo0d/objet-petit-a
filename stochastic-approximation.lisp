(in-package #:objet-petit-a)
(defun random-binary (_)
  (declare (ignore _))
  (if (> (random 2) 0) 1.0d0 -1.0d0))
(defclass common-random-number ()
  ((random-state :initform (make-random-state))))
(defmethod-1 run (:after) (common-random-number)
  ;; Scramble RANDOM-STATE at the beginning of run
  (random most-positive-fixnum random-state))
(defmethod-1 cost () (common-random-number parameter)
  (let ((*random-state* (make-random-state random-state)))
    (call-next-method)))
;; Spall, James C. "Multivariate stochastic approximation using a simultaneous perturbation gradient approximation." IEEE transactions on automatic control 37, no. 3 (1992): 332-341.
(defclass 1spsa (problem)
  ((step-size :initarg :step-size :accessor step-size)
   (gradient :accessor gradient))
  (:documentation
   "First-order simultaneous perturbation stochastic approximation.
    Support GRADIENT estimation."))
(defmethod-1 run (:after) (1spsa)
  (let* ((delta (m:map! #'random-binary (m:zeros (m:shape parameter))))
         (step (m:scale delta step-size))
         (cost+ (cost self (m:.+ parameter step)))
         (cost- (cost self (m:.- parameter step))))
    (setf gradient (m:scale! delta (/ (- cost+ cost-) 2 step-size)))))
;; Spall, James C. "Accelerated second-order stochastic optimization using only function measurements." In Proceedings of the 36th IEEE Conference on Decision and Control, vol. 2, pp. 1417-1424. IEEE, 1997.
(defclass 2spsa (problem)
  ((beta-h :initarg :beta-h :accessor beta-h)
   (step-factor :accessor step-factor)
   (step-size :initarg :step-size :accessor step-size)
   (hessian :accessor hessian)
   (average-hessian)
   (gradient :accessor gradient))
  (:documentation
   "Second-order simultaneous perturbation stochastic approximation.
    Support GRADIENT and HESSIAN estimation. HESSIAN is averaged with
    momentum BETA-H. The estimated HESSIAN could very likely be
    non-positive definite, therefore some kind of preconditioning is
    recommended."))
(defmethod-1 shared-initialize (:after) (2spsa slot-names &key &allow-other-keys)
  (psetq average-hessian (m:eye `(,@(m:shape parameter) ,@(m:shape parameter)))
         step-factor (m:const step-size (m:shape parameter))))
(defmethod-1 run (:after) (2spsa)
  (let* ((delta-1 (m:map! #'random-binary (m:zeros (m:shape parameter))))
         (delta-2 (m:map! #'random-binary (m:zeros (m:shape parameter))))
         (1/step-factor (m:map #'/ step-factor))
         (step-1 (m:.* delta-1 step-factor))
         (step-2 (m:.* delta-2 step-factor))
         (cost+0 (cost self (m:.+ parameter step-1)))
         (cost-0 (cost self (m:.- parameter step-1)))
         (cost++ (cost self (m:.+ (m:.+ parameter step-1) step-2)))
         (cost-+ (cost self (m:.+ (m:.- parameter step-1) step-2)))
         (grad (m:scale (m:.* delta-1 1/step-factor) (/ (- cost+0 cost-0) 2)))
         (grad2 (m:scale (m:.* delta-1 1/step-factor) (/ (- cost++ cost-+) 2)))
         (dgrad (m:.* (m:.- grad2 grad) 1/step-factor))
         (hessian-1 (m:scale! (m:mult (m:reshape dgrad `(,@(m:shape parameter) 1))
                                    (m:reshape delta-2 `(1 ,@(m:shape parameter))))
                            0.25))
         (hessian-1 (m:.+ hessian-1 (m:transpose hessian-1))))
    (setq gradient grad)
    (m:scale! average-hessian beta-h)
    (setf hessian (m:.+ average-hessian (m:scale! hessian-1 (- 1.0 beta-h)) average-hessian))))
(defclass adaptive-step-size () ())
(defmethod-1 run (:after) (adaptive-step-size)
  (setf (step-factor self)
        (m:map (lambda (x) (+ (abs (* 100.0 x)) (step-size self))) (gradient self))))
;; predefined recipes
#+nil (defclass sfn-2spsa (newton damp-hessian sfn 2spsa) ())

(in-package #:objet-petit-a)
(defun random-binary (_)
  (declare (ignore _))
  (if (> (random 2) 0) 1.0d0 -1.0d0))
(defclass common-random-number ()
  ((random-state :initform (make-random-state))))
(defmethod-1 run () (common-random-number)
  ;; Scramble RANDOM-STATE at the beginning of run
  (random most-positive-fixnum random-state))
(defmethod-1 cost () (common-random-number parameter)
  (let ((*random-state* (make-random-state random-state)))
    (call-next-method)))
;; Spall, James C. "Multivariate stochastic approximation using a simultaneous perturbation gradient approximation." IEEE transactions on automatic control 37, no. 3 (1992): 332-341.
(defclass 1spsa (problem)
  ((step-size :initarg :step-size :accessor step-size)
   (gradient :accessor gradient))
  (:documentation
   "First-order simultaneous perturbation stochastic approximation.
    Support GRADIENT estimation."))
(defmethod-1 run () (1spsa)
  (call-next-method)
  (let* ((delta (m:map! #'random-binary (m:zeros (m:shape parameter))))
         (step (m:scale delta step-size))
         (cost+ (cost self (m:.+ parameter step)))
         (cost- (cost self (m:.- parameter step))))
    (setf gradient (m:scale! delta (/ (- cost+ cost-) 2 step-size)))))
;; Spall, James C. "Accelerated second-order stochastic optimization using only function measurements." In Proceedings of the 36th IEEE Conference on Decision and Control, vol. 2, pp. 1417-1424. IEEE, 1997.
(defclass 2spsa (problem)
  ((beta-h :initarg :beta-h :accessor beta-h)
   (step-factor)
   (average-hessian :accessor hessian)
   (gradient :accessor gradient))
  (:documentation
   "Second-order simultaneous perturbation stochastic approximation.
    Support GRADIENT and HESSIAN estimation. HESSIAN is averaged with
    momentum BETA-H. The estimated HESSIAN could very likely be
    non-positive definite, therefore some kind of preconditioning is
    recommended."))
(defmethod-1 shared-initialize (:after) (2spsa slot-names &key step-size &allow-other-keys)
  (s:ensure step-factor (m:const step-size (m:shape parameter)))
  (setf average-hessian (m:eye `(,@(m:shape parameter) ,@(m:shape parameter))))
  #+nil (setf step-factor (m:const 0.1 (m:shape parameter))))
(defmethod-1 run () (2spsa)
  (call-next-method)
  (let* ((delta-1 (m:map! #'random-binary (m:zeros (m:shape parameter))))
         (delta-2 (m:map! #'random-binary (m:zeros (m:shape parameter))))
         #+nil (step-factor (m:.+ (m:scale! average-step 0.95)
                            (m:scale! (m:map #'abs (s:ensure (last-step self) (m:const 0.1 (m:shape parameter))))
                                      0.5)
                            average-step))
         (1/step-factor (m:map #'/ step-factor))
         (step-1 (m:.* delta-1 step-factor))
         (step-2 (m:.* delta-2 step-factor))
         (cost+0 (cost self (m:.+ parameter step-1)))
         (cost-0 (cost self (m:.- parameter step-1)))
         (cost++ (cost self (m:.+ (m:.+ parameter step-1) step-2)))
         (cost-+ (cost self (m:.+ (m:.- parameter step-1) step-2)))
         (grad (m:scale (m:.* delta-1 1/step-factor) (/ (- cost+0 cost-0) 2)))
         (grad2 (m:scale (m:.* delta-1 1/step-factor) (/ (- cost++ cost-+) 2)))
         (dgrad (m:.* (m:.- grad2 grad) 1/step-factor))
         (hessian (m:scale! (m:mult (m:reshape dgrad `(,@(m:shape parameter) 1))
                                    (m:reshape delta-2 `(1 ,@(m:shape parameter))))
                            0.25))
         (hessian (m:.+ hessian (m:transpose hessian))))
    (setq gradient grad)
    #+nil (print (list step-factor gradient parameter cost+0 cost-0 cost++ cost-+))
    #+nil (break)
    #+nil (m:scale! gradient 0.5)
    #+nil (m:.+ gradient (m:scale! grad (- 1.0 0.5)) gradient)
    (m:scale! average-hessian beta-h)
    (m:.+ average-hessian (m:scale! hessian (- 1.0 beta-h)) average-hessian)))

;; predefined recipes
#+nil (defclass sfn-2spsa (newton damp-hessian sfn 2spsa) ())

(in-package #:objet-petit-a)
(defgeneric gradient (search-node))
(defclass gradient-descent ()
  ((learning-rate :initarg :learning-rate :accessor learning-rate)))
(defmethod-1 run (:after) (gradient-descent)
  (m:.+ (parameter self) (m:scale (gradient self) (- learning-rate)) (parameter self)))
(defconstant +1/phi+ (/ (- (sqrt 5.0) 1.0) 2))
(defconstant +1/phi^2+ (- 1.0 +1/phi+))
(defclass golden-search () ())
(defmethod-1 run (:after) (golden-search)
  (labels ((process (a b c d yc yd)
             (when (< (- b a) 0.1) (return-from process (/ (+ a b) 2)))
             (s:ensure c (a:lerp +1/phi^2+ a b))
             (s:ensure d (a:lerp +1/phi+ a b))
             (s:ensure yc (cost self (m:.+ (parameter self) (m:scale (gradient self) c))))
             (s:ensure yd (cost self (m:.+ (parameter self) (m:scale (gradient self) d))))
             (if (< yc yd)
                 (process a d nil c nil yc)
                 (process c b d nil yd nil))))
    #+nil (print (list (m:lisp-array (parameter self)) (m:lisp-array (gradient self))))
    (m:.+ (parameter self)
          (m:scale (gradient self) (process 0.0 0.5 nil nil nil nil))
          (parameter self))))
(defclass newton ()
  ((learning-rate :initarg :learning-rate :accessor learning-rate)))
(defmethod-1 run (:after) (newton)
  (setf (gradient self) (m:linear-solve (hessian self) (gradient self))))
(defclass momentum () ((average-gradient) (momentum-factor :initarg :momentum-factor))
  (:default-initargs :momentum-factor 0.95))
(defmethod-1 shared-initialize (:after) (momentum slot-names &key &allow-other-keys)
  (setf average-gradient (m:copy-tensor (parameter self))))
(defmethod-1 run (:after) (momentum)
  (m:scale! average-gradient momentum-factor)
  (m:.+ average-gradient (m:scale! (gradient self) (- 1.0 momentum-factor)) average-gradient)
  (setf (gradient self) average-gradient))
(defclass sfn () ()
  (:documentation "Mixin for saddle-free newton preconditioning on Hessian."))
(defmethod-1 run (:after) (sfn)
  (multiple-value-bind (l v) (m:eig (hessian self))
    (setf (hessian self) (m:@ v (m:from-diag (mapcar #'abs l)) (m:transpose v)))))
(defclass damp-hessian ()
  ((delta :initarg :delta :accessor delta))
  (:default-initargs :delta 0.01d0)
  (:documentation "H=H+δI"))
(defmethod-1 run (:after) (damp-hessian)
  (m:.+ (m:scale! (m:eye (m:shape (hessian self))) delta) (hessian self) (hessian self)))
(defclass damp-hessian-si ()
  ((lam :initarg :lam :accessor lam))
  (:default-initargs :lam 1.0d0)
  (:documentation "H=H+λdiag(H). This term is scale-invariant."))
(defmethod-1 run (:after) (damp-hessian-si)
  (m:.+ (m:from-diag (mapcar (a:curry #'* lam) (m:diag (hessian self)))) (hessian self) (hessian self)))

(declaim (inline fastlog2))
(defun fastlog2 (p)
  "Compute log2(P) approximately for *positive* integer P.
Result is SINGLE-FLOAT."
  (declare (type fixnum p) (optimize (speed 3) (safety 0)))
  (let* ((exponent (1- (integer-length p)))
         (x (scale-float (coerce p 'single-float) (- exponent))))
    (declare (type single-float x))
    (+ exponent (- (* -0.4326728 x (- x 5.261706)) 1.8439242))))

(defclass metro-hastings (problem)
  ((beta-m :initarg :beta-m :accessor beta-m)
   (candidates) (candidate-costs)
   (cached-cost))
  (:default-initargs :beta-m 5.0))
(defgeneric mutate (search-node parameter candidates))
(defmethod-1 shared-initialize (:after) (metro-hastings slot-names &key &allow-other-keys)
  (psetf candidates (s:vect) candidate-costs (make-array 0 :adjustable t))
  (slot-makunbound self 'cached-cost))
(defmethod-1 run () (metro-hastings)
  (setf (fill-pointer candidates) 0)
  (mutate self parameter candidates)
  (adjust-array candidate-costs (length candidates) :initial-element nil)
  (iter (for i index-of-vector candidate-costs)
    (setf (aref candidate-costs i) nil))
  (iter
    (with cost-0 = (s:ensure cached-cost (cost self parameter)))
    (for choice = (random (length candidates)))
    (for candidate = (aref candidates choice))
    (for cost-1 = (s:ensure (aref candidate-costs choice)
                    (cost self candidate)))
    (when (or (< cost-1 cost-0)
              (< (+ (fastlog2 (1+ (random 1000))) (* beta-m (- cost-1 cost-0)))
                 (fastlog2 (1+ 1000))))
      (return (psetf cached-cost cost-1 parameter candidate)))))

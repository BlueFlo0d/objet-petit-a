(in-package #:objet-petit-a)
(defgeneric gradient (search-node))
(defclass gradient-descent ()
  ((learning-rate :initarg :learning-rate :accessor learning-rate)))
(defmethod-1 run () (gradient-descent)
  (call-next-method)
  (m:.+ (parameter self) (m:scale (gradient self) (- learning-rate)) (parameter self)))
(defgeneric hessian (search-node))
(defclass newton ()
  ((learning-rate :initarg :learning-rate :accessor learning-rate)
   (last-step :accessor last-step)))
(defmethod-1 run () (newton)
  (call-next-method)
  (m:.+ (parameter self)
        (setq last-step
              (m:scale! (m:linear-solve (hessian self) (gradient self))
                        (- learning-rate)))
        (parameter self)))
(defclass sfn () ()
  (:documentation "Mixin for saddle-free newton preconditioning on Hessian."))
(defmethod-1 hessian () (sfn)
  (multiple-value-bind (l v) (m:eig (call-next-method))
    (m:@ v (m:from-diag (mapcar #'abs l)) (m:transpose v))))
(defclass damp-hessian ()
  ((delta :initarg :delta :accessor delta))
  (:default-initargs :delta 0.01d0)
  (:documentation "H=H+δI"))
(defmethod-1 hessian () (damp-hessian)
  (let ((hessian-1 (call-next-method)))
    (m:.+ (m:scale! (m:eye (m:shape hessian-1)) delta) hessian-1)))
(defclass damp-hessian-si ()
  ((lam :initarg :lam :accessor lam))
  (:default-initargs :lam 1.0d0)
  (:documentation "H=H+λdiag(H). This term is scale-invariant."))
(defmethod-1 hessian () (damp-hessian-si)
  (let ((hessian-1 (call-next-method)))
    (m:.+ (m:from-diag (mapcar (a:curry #'* lam) (m:diag hessian-1))) hessian-1)))

(declaim (inline fastlog2))
(defun fastlog2 (p)
  "Compute log2(P) approximately for *positive* integer P.
Result is SINGLE-FLOAT."
  (declare (type fixnum p) (optimize (speed 3) (safety 0)))
  (let* ((exponent (1- (integer-length p)))
         (x (scale-float (coerce p 'single-float) (- exponent))))
    (declare (type single-float x))
    (+ exponent (- (* -0.4326728 x (- x 5.261706)) 1.8439242))))

(defclass metro-hastings (problem)
  ((beta-m :initarg :beta-m :accessor beta-m)
   (candidates :initform (s:vect))
   (candidate-costs :initform (make-array 0 :adjustable t))
   (cached-cost))
  (:default-initargs :beta-m 5.0))
(defgeneric mutate (search-node parameter candidates))
(defmethod-1 cost () (metro-hastings parameter-1)
  (if (eq parameter-1 parameter)
      (s:ensure cached-cost (call-next-method))
      (call-next-method)))
(defmethod-1 shared-initialize (:after) (metro-hastings slot-names &key &allow-other-keys)
  (slot-makunbound self 'cached-cost))
(defmethod-1 run () (metro-hastings)
  (setf (fill-pointer candidates) 0)
  (mutate self parameter candidates)
  (adjust-array candidate-costs (length candidates))
  (iter (for i index-of-vector candidate-costs)
    (setf (aref candidate-costs i) nil))
  (iter
    (for choice = (random (length candidates)))
    (for candidate = (aref candidates choice))
    (for cost-1 = (s:ensure (aref candidate-costs choice)
                    (cost self candidate)))
    (when (or (< cost-1 cached-cost)
              (< (+ (fastlog2 (1+ (random 1000))) (* beta-m (- cost-1 cached-cost)))
                 (fastlog2 (1+ 1000))))
      (return (psetf cached-cost cost-1 parameter candidate)))))

(in-package #:objet-petit-a)
(define-condition found-promising-state ()
  ((search-node :initarg :search-node :accessor search-node)
   (eval-cost :initarg :eval-cost :accessor eval-cost)))
(defclass controller ()
  ((best-nodes :initform nil) (n-best :initarg :n-best) (last-report-time :initform 0)
   (search-node :initarg :search-node :accessor search-node)
   (eval-interval :initarg :eval-interval))
  (:default-initargs :eval-interval 100 :n-best 10))
(defgeneric eval-cost (problem)
  (:method ((self problem)) (cost self (parameter self))))
(defmethod-1 run () (controller)
  (iter (for i below eval-interval)
    (restart-case
        (run search-node)
      (continue-from-best ()
        :test (lambda (c) best-nodes)
        (reinitialize-instance search-node :parameter (copy (parameter (cdar best-nodes)))))))
  (let ((eval-cost (eval-cost search-node)))
    (when (or (not best-nodes)
              (< eval-cost (caar (last best-nodes))))
      (setq search-node (copy search-node))
      (push (cons eval-cost search-node) best-nodes)
      (setq best-nodes (sort best-nodes #'< :key #'car))
      (a:when-let (tail (nthcdr (1- n-best) best-nodes))
        (rplacd tail nil))
      (restart-case
          (progn
            (signal 'found-promising-state :search-node search-node :eval-cost eval-cost)
            (let ((time (get-internal-real-time)))
              (when (> time (+ last-report-time internal-time-units-per-second))
                (format *trace-output* "~&Found ~a with eval-cost ~a.~%" (parameter search-node) eval-cost)
                (setq last-report-time time))))
        (continue ())))))

(define-condition state-not-promising () ())

(defclass fix-restart (controller)
  ((n-restart :initarg :n-restart)
   (parameter-0 :initarg :parameter)
   (timeout :initarg :timeout)
   (thread :initform nil))
  (:default-initargs :n-restart 1000 :timeout nil))
(defun debug-p (thread)
  (let ((db-level (sb-thread:symbol-value-in-thread 'swank::*sldb-level* thread nil)))
    (and db-level (> db-level 0))))
(defmethod-1 run () (fix-restart)
  (reinitialize-instance search-node :parameter (copy parameter-0))
  (let ((thread sb-thread:*current-thread*))
    (handler-bind
        ((sb-ext:timeout
           (lambda (c)
             (if (debug-p thread)
                 (invoke-restart 'abort)
                 (return-from run)))))
      (sb-ext:with-timeout timeout
        (iter (for i below n-restart)
          (call-next-method))))))
;; Luby, Michael, Alistair Sinclair, and David Zuckerman. "Optimal speedup of Las Vegas algorithms." Information Processing Letters 47, no. 4 (1993): 173-180.
(defun luby-sequence-next (sequence)
  (let* ((epoches+1 (+ 2 (length sequence)))
         (k (integer-length (1- epoches+1)))
         (result (if (= (ash 1 k) epoches+1)
                     (ash 1 (1- k))
                     (aref sequence (- epoches+1 (ash 1 (1- k)) 1)))))
    (vector-push-extend result sequence)
    result))
(defclass luby-restart (controller)
  ((luby-sequence :initform (s:vect))
   (luby-t0 :initarg :luby-t0)
   (parameter-0 :initarg :parameter))
  (:default-initargs :luby-t0 100))
(defmethod-1 run () (luby-restart)
  (reinitialize-instance search-node :parameter (copy parameter-0))
  (let ((run-length (luby-sequence-next luby-sequence)))
    (print run-length)
    (handler-case
        (iter (for i below (* luby-t0 run-length))
          (call-next-method))
      (state-not-promising () nil))))
